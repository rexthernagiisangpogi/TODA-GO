rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper to read the requestor's user doc once
    function me() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid));
    }

    // Allow each authenticated user to manage their own user document
    match /users/{userId} {
      allow get, list: if request.auth != null; // Allow all authenticated users to read profiles
      allow create, update, delete: if request.auth != null && request.auth.uid == userId;
      // Optionally restrict which fields can be updated by the user. Example:
      // allow update: if request.auth.uid == userId
      //   && request.resource.data.diff(resource.data).changedKeys().hasOnly([
      //     'fcmToken', 'fcmTokenUpdatedAt', 'settings', 'phone', 'name',
      //     'toda', 'licenseNumber', 'vehicleInfo', 'email', 'role'
      //   ]);
    }

    // Pickups: queried by drivers (by TODA + status) and created by passengers
    match /pickups/{pickupId} {
      // READ - Allow drivers to read pickups for their TODA and passengers to read their own
      allow read: if request.auth != null && (
        // Passengers can read their own pickups (check first to avoid me() call)
        resource.data.passengerId == request.auth.uid
        ||
        // Drivers can read pickups for their TODA (any status for map display)
        (
          me().data.userType == 'driver' &&
          resource.data.toda == me().data.toda
        )
        ||
        // Allow drivers to read pickups assigned to them
        (
          me().data.userType == 'driver' &&
          resource.data.driverId == request.auth.uid
        )
      );

      // CREATE: passengers create ride requests
      allow create: if request.auth != null && me().data.userType == 'passenger'
        // Minimal required fields; adjust per your schema
        && request.resource.data.keys().hasAll(['toda', 'status', 'passengerId'])
        && request.resource.data.passengerId == request.auth.uid;

      // UPDATE: drivers update the pickup they accepted OR assigned driver updates status
      allow update: if request.auth != null && (
        // Driver assigning themselves (accept ride): set driverId to auth.uid
        (
          me().data.userType == 'driver' &&
          request.resource.data.driverId == request.auth.uid
        )
        ||
        // Already-assigned driver updates status (onTheWay, completed, canceled)
        (
          me().data.userType == 'driver' &&
          resource.data.driverId == request.auth.uid
        )
        ||
        // Passenger updates their own pickup (e.g., cancel) â€” optional
        (
          me().data.userType == 'passenger' &&
          resource.data.passengerId == request.auth.uid
        )
      );

      // DELETE: typically not allowed from clients
      allow delete: if false;

      // Messages subcollection: allow driver and passenger to read/write messages
      match /messages/{messageId} {
        // READ: Allow driver and passenger of the pickup to read messages
        allow read: if request.auth != null && (
          // Driver can read if they are assigned to this pickup
          (
            me().data.userType == 'driver' &&
            get(/databases/$(database)/documents/pickups/$(pickupId)).data.driverId == request.auth.uid
          )
          ||
          // Passenger can read if this is their pickup
          (
            me().data.userType == 'passenger' &&
            get(/databases/$(database)/documents/pickups/$(pickupId)).data.passengerId == request.auth.uid
          )
        );

        // CREATE: Allow driver and passenger to send messages
        allow create: if request.auth != null && (
          // Driver can send if they are assigned to this pickup
          (
            me().data.userType == 'driver' &&
            get(/databases/$(database)/documents/pickups/$(pickupId)).data.driverId == request.auth.uid &&
            request.resource.data.senderId == request.auth.uid
          )
          ||
          // Passenger can send if this is their pickup
          (
            me().data.userType == 'passenger' &&
            get(/databases/$(database)/documents/pickups/$(pickupId)).data.passengerId == request.auth.uid &&
            request.resource.data.senderId == request.auth.uid
          )
        ) && request.resource.data.keys().hasAll(['text', 'senderId', 'senderType', 'timestamp']);

        // UPDATE/DELETE: Messages are immutable once sent
        allow update, delete: if false;
      }
    }

    // Ratings: allow creating, reading, and updating ratings
    match /ratings/{ratingId} {
      // CREATE: allow users to create ratings
      allow create: if request.auth != null
        && request.resource.data.raterId == request.auth.uid;
      
      // READ: allow all authenticated users to read ratings
      allow read: if request.auth != null;
      
      // UPDATE: allow users to update ratings they created
      allow update: if request.auth != null 
        && resource.data.raterId == request.auth.uid;
      
      // DELETE: typically not allowed
      allow delete: if false;
    }

    // Notifications (if enqueued from the client). Prefer using Cloud Functions; relax only if needed.
    match /notifications/{docId} {
      allow create: if request.auth != null;
      allow read, update, delete: if false;
    }
  }
}
